/* --- Libraries --- */
// System.
using System.Collections;
using System.Collections.Generic;
// Unity.
using UnityEngine;

/* --- Definitions --- */
using Game = Platformer.Management.GameManager;

namespace Platformer.Objects.Decorations {

    /// <summary>
    ///
    /// <summary>
    [RequireComponent(typeof(EdgeCollider))]
    public class Rope : MonoBehaviour {

        //
        protected const float ACCELERATION_DAMPING = 0.975f;

        protected const float VELOCITY_DAMPING = 0.65f;

        //
        protected const float SEGMENT_LENGTH  = 6f/16f;
        
        //
        protected LineRenderer m_SpriteShape;
        
        //
        protected EdgeCollider2D m_EdgeCollider;

        //

        protected int segmentCount; // The number of segments.
        
        [SerializeField] 
        public Transform startpoint; // The width of the rope.
        
        protected Vector3 m_Gravity = new Vector3(0f, -1.5f, 0f);
        
        [SerializeField] 
        protected int CONSTRAINT_DEPTH = 5;
        
        // The width of the rope.
        [SerializeField] 
        public float ropeLength; 
        
        // The width of the rope.
        [SerializeField] 
        public float ropeWidth; 
        
        // The current positions of the segments.
        [SerializeField] 
        protected Vector3[] ropeSegments; 
        
        // The previous positions of the segments.
        [SerializeField] 
        protected Vector3[] prevRopeSegments; 
        
        // The previous positions of the segments.
        [SerializeField] 
        protected Vector3[] velocities; 

        /* --- Unity --- */
        // Runs once on initialization.
        void Awake() {
            // Cache these references.
            m_SpriteShape = GetComponent<LineRenderer>();
            m_EdgeCollider = GetComponent<EdgeCollider2D>();
            m_Gravity = new Vector3(UnityEngine.Physics2D.gravity.x, UnityEngine.Physics2D.gravity.y, 0f);
            // Set up these components.
            m_SpriteShape.useWorldSpace = false;
            m_SpriteShape.startWidth = ropeWidth;
            m_SpriteShape.endWidth = ropeWidth;
            m_EdgeCollider.edgeRadius = ropeWidth;
            OnAwake();
            RopeSegments();
        }

        // Runs once every set time interval.
        void FixedUpdate() {
            Simulate(Time.fixedDeltaTime);
        }

        // Runs if this trigger is activated.
        void OnTriggerStay2D(Collider2D collider) {
            if (collider.GetComponent<Rigidbody2D>()) {
                Jiggle(collider);
            }
        }

        private void Simulate(float dt) {
            
            for (int i = 0; i < segmentCount; i++) {
                Vector3 velocity = ropeSegments[i] - prevRopeSegments[i];
                prevRopeSegments[i] = ropeSegments[i];
                ropeSegments[i] += velocity * ACCELERATION_DAMPING;
                ropeSegments[i] += m_Gravity * dt;
                ropeSegments[i] += velocities[i] * dt;
            }

            for (int i = 0; i < velocities.Length; i++) {
                velocities[i] *= VELOCITY_DAMPING;
            }

            for (int i = 0; i < CONSTRAINT_DEPTH; i++) {
                Constraints();
            }

            m_SpriteShape.positionCount = segmentCount;
            m_SpriteShape.SetPositions(ropeSegments);

            Vector2[] points = new Vector2[segmentCount];
            for (int i = 0; i < segmentCount; i++) {
                m_SpriteShape.spline.SetPositions(i, )
                m_EdgeCollider.points[i] = (Vector2)ropeSegments[i];
            }

            m_EdgeCollider.points = points;
            
        }

        /* --- Methods --- */
        // Initalizes the rope segments.
        void RopeSegments() {
            // Get the number of segments for a rope of this length.
            segmentCount = (int)Mathf.Ceil(ropeLength / SEGMENT_LENGTH);

            // Initialize the rope segments.
            ropeSegments = new Vector3[segmentCount];
            prevRopeSegments = new Vector3[segmentCount];
            velocities = new Vector3[segmentCount];
            
            ropeSegments[0] = Vector3.zero;
            prevRopeSegments[0] = ropeSegments[0];
            velocities[0] = Vector2.zero;

            for (int i = 1; i < segmentCount; i++) {
                Vector2 offset = SEGMENT_LENGTH * Random.insideUnitCircle.normalized;
                offset.y = -Mathf.Abs(offset.y);
                ropeSegments[i] = ropeSegments[i - 1] + (Vector3)offset;
                prevRopeSegments[i] = ropeSegments[i];
                velocities[i] = new Vector2(0f, 0f);
            }
        }

        // Adds a jiggle whenever a body collides with this.
        void Jiggle(Collider2D collider) {
            Rigidbody2D body = collider.GetComponent<Rigidbody2D>();
            // Get the segment closest to the collider.
            Vector3 pos = collider.transform.position;
            int index = 1;
            float minDist = 1e9f;
            for (int i = 1; i < segmentCount; i++) {

                Vector3 segPos = transform.position + ropeSegments[i];

                float dist = (pos - segPos).magnitude;
                if (dist < minDist) {
                    index = i;
                    minDist = dist;
                }

            }
            // Add a jiggle to this segment.
            velocities[index] = body.velocity; // body.gravityScale /  
        }

        protected virtual void OnAwake() {

        }

        protected virtual void Constraints() {
            //
        }

    }

}
