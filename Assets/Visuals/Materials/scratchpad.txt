            
                
                // float2 screenCenter = float2(_ScreenParams.x / 2.0, _ScreenParams.y / 2.0);
                // float2 pixelCoord = float2(i.uv.x * _ScreenParams.x, i.uv.y * _ScreenParams.y);
                // float dist = dot(screenCenter, pixelCoord);

                // float2 vertex = i.vertex.xy; /// i.vertex.w;
                // float2 pixelCoord = float2(i.uv.x, i.uv.y);
                vertex = vertex.xy / _ScreenParams.x;// / i.vertex.w;
                // vertex.y *= _ScreenParams.y;
                // vertex.x *= _ScreenParams.x;
                float dist = length(vertex + _Origin);
                // if (dist < _Radius * _Radius) {
                //     return fixed4(1, 0, 0, 1);
                // }
                // else {
                //     return fixed4(0, 0, 0, 1);
                // }




            // Fast branchless RGB to HSV conversion in GLSL
            // Modified for HLSL
            // From https://web.archive.org/web/20200207113336/http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl.
            float3 rgb2hsv(float3 c) { 
                float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                // Using the ternary to force a cmov in the compilation.
                float4 p = c.g < c.b ? float4(c.bg, K.wz) : float4(c.gb, K.xy);
                float4 q = c.r < p.x ? float4(p.xyw, c.r) : float4(c.r, p.yzx);
                float d = q.x - min(q.w, q.y);
                return float3(abs(q.z + (q.w - q.y) / (6.0 * d + Epsilon)), d / (q.x + Epsilon), q.x);
            }

            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }